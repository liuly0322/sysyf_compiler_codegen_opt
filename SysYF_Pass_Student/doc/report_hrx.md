# 实验报告

## 必做部分

### 支配树

#### B1-1

记入口点是 $e$，$x\text{ dom }b\Rightarrow\forall p(e,b),x\in p$，$y\text{ dom }b\Rightarrow\forall p(e,b),y\in p$。

取一条 $e,b$ 之间的路径 $p'(e,b)$，已知 $x,y\in p'$，假设 $p'$ 上所有的 $x,y$ 节点中离 $b$ 最近的是一个 $y$ 节点，$p'$ 上从这个 $y$ 节点到 $b$ 的子路（记为 $p^*$）不包含 $x$。

如果 $x$ 不支配 $y$，则存在 $e,y$ 之间的路径 $p''(e,y),x\not\in p''$。取新路 $\tilde{p}(e,b)=p''\cup p^*$，可知 $x\not \in \tilde{p}$，与 $x\text{ dom }b$ 矛盾。

反之，假设 $p'$ 上所有的 $x,y$ 节点中离 $b$ 最近的是一个 $x$ 节点，$p'$ 上从这个 $x$ 节点到 $b$ 的子路（记为 $p^*$）不包含 $y$。

如果 $y$ 不支配 $x$，则存在 $e,x$ 之间的路径 $p''(e,x),y\not\in p''$。取新路 $\tilde{p}(e,b)=p''\cup p^*$，可知 $y\not \in \tilde{p}$，与 $y\text{ dom }b$ 矛盾。

所以，如果 $x\text{ dom }b$ 且 $y\text{ dom }b$，则必有 $x\text{ dom }y$ 或 $y\text{ dom }x$。

#### B1-2

使用逆后序遍历顺序，可以保证当访问一个非 $e$ 节点（比如 $x$）时，其所有前驱都已经被访问过，这样访问之后可以保证对 $x$ 的更新是有效的。在这里的 for 循环中，我们只要保证取出节点的顺序满足上述条件即可。图 $G$ 的任何拓扑排序的逆序皆可。

#### B1-3

同上。

#### B1-4

`intersect` 是取交集，实际上因为 DOM 集合规定了顺序，交集计算只需要将索引指针不断左移即可。

不可以只改变内层两个 while 循环的小于号，因为 doms 数组记录了支配树上自下而上的信息，更新过程按照逆后序遍历的索引顺序，需要更新的索引是越来越小的，因此按照当前的框架，这里的符号一定是小于号。

#### B1-5

**时间复杂度**：教材算法和论文算法的迭代次数上界是一样的，在支配树上计算一个逆后序序列所需的时间也是一样的，即 $O(N)$。每次迭代的时间 = 计算后序序列时间 + 对每条边执行 `intersect` 操作的时间，后者时间复杂度为 $O(D)$，$D$ 是最大 DOM 集合的大小，所以平均迭代时间为 $O(N+E·D)$。教材算法没有优化数据结构，每次都需要使用一个新的集合，时间复杂度至少是 $O(D(N+E))$ 的。

**空间复杂度**：论文算法只需要维护 doms 数组，空间复杂度是 $O(N)$；教材算法对每个节点都需要维护 DOM 集合，空间复杂度是 $O(N^2)$。

#### B1-6

在 `RDominateTree` 中，是使用如下代码确定 exit 节点的：

```C++
for (auto bb : f->get_basic_blocks()) {
	auto terminate_instr = bb->get_terminator();
	if (terminate_instr->is_ret()){
		exit_block = bb;
		break;
	}
}
```

也就是选取以 ret 指令结尾的块作为 exit 节点（这种实现认为只有一个块包括 ret 指令）。流图的最后一个基本块不一定以 ret 指令结尾，也就是说不一定是函数的出口，所以不能将流图的最后一个基本块认为是 exit 节点。

### Mem2Reg

#### B2-1

#### B2-2

#### B2-3

### 活跃变量分析

#### B3-1

### 检查器

#### B4-1
