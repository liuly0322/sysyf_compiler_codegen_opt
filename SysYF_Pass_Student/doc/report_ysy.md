# 实验报告

## 必做部分

### 支配树

#### B1-1

> 证明：若 $x$ 和 $y$ 支配 $b$，则要么 $x$ 支配 $y$，要么 $y$ 支配 $x$。

反证：若 $x$ 和 $y$ 支配 $b$, 假设 $x$ 不支配 $y$ 且 $y$ 也不支配 $x$。

考虑一条从入口 $n_0$ 到 $b$ 的路径，由 $x$ 和 $y$ 均支配 $b$，因此 $x$ 和 $y$ 都在这条路径上，事实上这条路径总可以写成 $P(n_0,\ x) + P(x,\ b)$（其中 $P(x,\ b)$ 不含 $y$）或者 $P(n_0,\ y) + P(y,\ b)$（其中 $P(y,\ b)$ 不含 $x$）

- 由于 $x$ 不支配 $y$，因此存在一条从 $n_0$ 到 $y$ 的路径不含 $x$，记为 $P_1(n_0,\ y)$；
- 由于 $y$ 不支配 $x$，因此存在一条从 $n_0$ 到 $x$ 的路径不含 $y$；记为 $P_1(n_0,\ x)$

因此 $P(n_0,\ x) + P(x,\ b)$ 可以被替换为 $P_1(n_0,\ x) + P(x,\ b)$，为一条从 $n_0$ 到 $b$ 的路径且不含 $x$，这与 $x$ 支配 $b$ 矛盾！

(对于 $P(n_0,\ y) + P(y,\ b)$ 同理可得)

综上，若 $x$ 和 $y$ 支配 $b$，则要么 $x$ 支配 $y$，要么 $y$ 支配 $x$。

#### B1-2

> 在 [dom.pdf](doc/dom.pdf) 中，`Figure 1: The Iterative Dominator Algorithm` 是用于计算支配关系的迭代算法，该算法的内层 `for` 循环是否一定要以后序遍历的逆序进行，为什么？

此处后序遍历的逆序目是保证访问某个结点时，其所有前驱已经被访问了，这样完成更新该结点才有效。

遍历的顺序应该并不唯一，如上所述，只需要保证访问某个结点其所有前驱已被访问即可，不过后序遍历的逆序确实算是一个简单的能满足此要求的遍历顺序。

#### B1-3

> `Figure 3: The Engineered Algorithm` 为计算支配树的算法。在其上半部分的迭代计算中，内层的 `for` 循环是否一定要以后序遍历的逆序进行，为什么？

这里目的与 `B1-2` 相同，保证访问某个结点其所有前驱已被访问，因此不唯一。

#### B1-4

> 在 [dom.pdf](doc/dom.pdf) 中，`Figure 3: The Engineered Algorithm` 为计算支配树的算法。其中下半部分 `intersect` 的作用是什么？内层的两个 `while` 循环中的小于号能否改成大于号？为什么？

`intersect` 的作用是取两个 Dom 集合的交集（实际是返回一个索引）。

不能换成大于号。在上半部分的迭代计算中，内层的 `for` 循环是以后序遍历的逆序进行，节点索引也是**后序遍历的逆序**，在支配树中越**上层**的结点其索引越**大**，因此取交集的时候，是要往上层更新为直接支配结点（`doms` 数组实际维护的是 IDom 信息），也就是说索引小的才应该要变化，因此是小于号。

如果要改成大于号，则上半部分迭代的顺序和索引的构建需要相应改变。

#### B1-5

> 这种通过构建支配树从而得到支配关系的算法相比教材中算法 9.6 在时间和空间上的优点是什么？

以下简称该算法为支配树算法，并且认为教材算法 9.6 为论文中初始提出的迭代算法(未经优化)。

- 时间上，考虑两种算法的迭代次数是一样的，因此以下比较单次迭代时间复杂度。支配树算法计算反向后序序列需要 $O(N)$ 时间。计算 Dom 和 IDom 的遍历访问每个节点，对于每个节点，在每条边上进行 `intersect`，在整个遍历过程中，做 $O(E)$ 次，所需时间与它们使用的 $Dom$ 集的大小成比例。因此，每次迭代的时间为$O(N+ED)$，其中 D 是最大 $Dom$ 集的大小。而算法 9.6 取决于集合的具体实现，以并查集为例，还要考虑并集时的复制开销，时间复杂度为 $O(ND + \alpha(D)ED)$，对比可见单次迭代的时间有较大改进。

- 空间上，支配树算法只需要维护 Doms 数组，而算法 9.6 需要为每一个节点维护一个 Dom 集合，前者只需 O(N)，而后者需要 $O(ND)$。


#### B1-6

> 在反向支配树的构建过程中，是怎么确定 EXIT 结点的？为什么不能以流图的最后一个基本块作为 EXIT 结点？

在 `RDominateTree::get_revserse_post_order` 中可以发现如下代码片段确定 EXIT 结点为第一个终结指令为 ret 的基本块。（但是这样做应该是假设只有一个有 ret）

```cpp
for (auto bb: f->get_basic_blocks()) {
    auto terminate_instr = bb->get_terminator();
    if (terminate_instr->is_ret()) {
        exit_block = bb;
        break;
    }
}
```

而流图的最后一个基本块实际上未必以 ret 结尾，比如可能是跳转指令，并非实际的出口，所以不能作为 EXIT 结点。

### Mem2Reg

#### B2-1

#### B2-2

#### B2-3

### 活跃变量分析

#### B3-1

### 检查器

#### B4-1